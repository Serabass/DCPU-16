<html>
<head>
  <title>DCPU-16 emulator</title>
  <script type="text/javascript" src="js/dcpu.js"></script>
  <style>
    body, button {
      font-family: Verdana, Tahoma, sans-serif;
      font-size: 14px;
    }
    button.big {
      font-size: 20px;
      width: 160px;
      height: 40px;
      text-align: left;
      margin: 4px;
    }
    .filewrap {
      margin: 6px 6px 0px 0px;
      position: relative;
      display: inline-block;
    }
    .filewrap .file {
      position: absolute;
      opacity: 0;
      -moz-opacity: 0;
      filter:alpha(opacity=0);
      margin: 0;
      width: 100%;
      height: 100%;
      z-index: -100;
    }

    h3 {
      font-size: 22px;
      margin-bottom: 0px;
    }
    table td {
      position: relative;
    }
    .editor, .editor td {
      font-family: Monaco, Lucida Console, Andale Mono, Courier New, Courier, monospace;
      font-size: 14px;
      line-height: 19px;
      margin: 0;
    }
    #linenums {
      padding: 2px 0px 2px 0px;
      text-align: right;
      color: gray;
    }
    #linenums u {
      margin: 1px 1px 2px 1px;
      padding: 1px 11px;
      line-height: 15px;
      text-decoration: none;
      display: block;
      cursor: pointer;
    }
    #linenums u.breakpoint {
      padding: 0px 10px;
      background-color: #adf;
      border: 1px solid #3ab;
      border-radius: 3px;
    }
    #offsets {
      padding: 4px 10px 2px 24px;
      color: gray;
    }
    #da_lines {
      padding: 4px 10px 2px 24px;
      color: gray;
    }
    #code {
      width: 100%;
      min-width: 500px;
      background-color: transparent;
    }
    #da_input {
      width: 100%;
      min-width: 200px;
    }
    #dump {
      overflow-x: auto;
      overflow-y: visible;
      white-space: nowrap;
      padding: 4px;
      width: 300px;
    }
    #da_code {
      padding: 4px;
    }
    #log {
      padding-top: 6px;
    }
    #log .line {
      color: gray;
    }
    #log .fatal {
      font-weight: bold;
      color: #900;
    }
    #memory_wrapper {
      position: relative;
    }
    #memory_window {
      overflow-y: scroll;
      width: 400px;
      height: 304px;
    }
    #memory_stub {
      height: 8480px;
    }
    #memory_view {
      position: relative;
      float: left;
      top: 0px;
      left:0px;
    }
    #memory_lines {
      position: relative;
      float: left;
      top: 0px;
      left: 0px;
      padding-right: 6px;
      color: gray;
    }
    .reg_name {
      padding-left: 20px;
      font-weight: bold;
      color: gray;
    }
    .cur_sp {
      background-color: #aaaaff;
      text-decoration: none;
    }
    .cur_pc {
      background-color: #aaffaa;
      text-decoration: none;
    }
    .line_highlight {
      background-color: #aaffaa;
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 19px;
      z-index: -1000;
    }
    .hlight_wrap {
      position: relative;
    }
    #screen {
      background-color: black;
      padding: 4px;
    }
    #screen u, #screen b {
      display: inline-block;
      width: 9px;
      height: 19px;
      text-decoration: none;
      font-weight: normal;
    }
    #screen .f0 {color: #000000;}
    #screen .f1 {color: #0000aa;}
    #screen .f2 {color: #00aa00;}
    #screen .f3 {color: #00aaaa;}
    #screen .f4 {color: #aa0000;}
    #screen .f5 {color: #aa00aa;}
    #screen .f6 {color: #aa5500;}
    #screen .f7 {color: #aaaaaa;}
    #screen .f8 {color: #555555;}
    #screen .f9 {color: #5555ff;}
    #screen .fa {color: #55ff55;}
    #screen .fb {color: #55ffff;}
    #screen .fc {color: #ff5555;}
    #screen .fd {color: #ff55ff;}
    #screen .fe {color: #ffff55;}
    #screen .ff {color: #ffffff;}

    #screen .b0 {background-color: #000000;}
    #screen .b1 {background-color: #0000aa;}
    #screen .b2 {background-color: #00aa00;}
    #screen .b3 {background-color: #00aaaa;}
    #screen .b4 {background-color: #aa0000;}
    #screen .b5 {background-color: #aa00aa;}
    #screen .b6 {background-color: #aa5500;}
    #screen .b7 {background-color: #aaaaaa;}
    #screen .b8 {background-color: #555555;}
    #screen .b9 {background-color: #5555ff;}
    #screen .ba {background-color: #55ff55;}
    #screen .bb {background-color: #55ffff;}
    #screen .bc {background-color: #ff5555;}
    #screen .bd {background-color: #ff55ff;}
    #screen .be {background-color: #ffff55;}
    #screen .bf {background-color: #ffffff;}

    #screen .h {visibility: hidden;}

    .notice {
      margin: 6px 0px 10px 0px;
      color: gray;
      font-size: 14px;
    }
    .notice a {
      color: black;
    }
    #tab1_wrapper {
      display: none;
    }
    #da_code .op {
      font-weight: bold;
      color: #700;
    }
    #da_code .reg {
      font-weight: bold;
      color: #070;
    }
    #da_code .lit {
      color: #007;
    }
    #da_code .kw {
      color: #077;
    }
    #da_code .lbl {
      color: #707;
    }
    .tabs {
      margin-bottom: 2px;
    }
    .tab_active {
      background-color: #8AE;
      color: white;
      padding: 2px 7px;
      text-decoration: none;
      border-radius: 4px 4px 0px 0px;
      margin: 0px 5px;
    }
    .tab_inactive {
      background-color: #FFF;
      color: #57C;
      padding: 2px 7px;
      text-decoration: none;
      border-radius: 4px 4px 0px 0px;
      margin: 0px 5px;
    }
    #disassembleDump {
      float: right;
      margin-top: 19px;
    }
  </style>
</head>
<body>
  <h3>DCPU-16 Assembler, Emulator &amp; Disassembler</h3>
  <div class="notice">by deNULL. Report any problems at <a href="mailto:me@denull.ru">me@denull.ru</a>.</div>

  <table width="100%" border=0 cellpadding=0 cellspacing=0 style="padding-top: 6px"><tr valign=top>
  <td width="80%">
    <div class="tabs"><a href="javascript:" onclick="toggleTab(0)" class="tab_active" id="tab0">Assembler</a><a href="javascript:" onclick="toggleTab(1)" class="tab_inactive" id="tab1">Disassembler</a></div>
    <div id="tab0_wrapper">
    <table width="100%" id="assembler" cellpadding=0 cellspacing=0><tr valign=top>
      <td width="20"><div class="hlight_wrap"><div class="line_highlight" id="hlight1"></div></div><div class="editor" id="linenums"></div></td>
      <td width="60%"><div class="hlight_wrap"><div class="line_highlight" id="hlight2"></div></div><textarea class="editor" id="code" onkeyup="assemble()" onchange="assemble()" wrap=off placeholder="Place your code here"><?php
$default_code = <<<EOF
    ; Try some basic stuff
                  SET A, 0x30              ; 7c01 0030
                  SET [0x1000], 0x20       ; 7de1 1000 0020
                  SUB A, [0x1000]          ; 7803 1000
                  IFN A, 0x10              ; c00d
                     SET PC, crash         ; 7dc1 001a [*]

    ; Do a loopy thing
                  SET I, 10                ; a861
                  SET A, 0x2000            ; 7c01 2000
    :loop         SET [0x2000+I], [A]      ; 2161 2000
                  SUB I, 1                 ; 8463
                  IFN I, 0                 ; 806d
                     SET PC, loop          ; 7dc1 000d [*]

    ; Call a subroutine
                  SET X, 0x4               ; 9031
                  JSR testsub              ; 7c10 0018 [*]
                  SET PC, crash            ; 7dc1 001a [*]

    :testsub      SHL X, 4                 ; 9037
                  SET PC, POP              ; 61c1

    ; Hang forever. X should now be 0x40 if everything went right.
    :crash        SET PC, crash            ; 7dc1 001a [*]

    ; [*]: Note that these can be one word shorter and one cycle faster by using the short form (0x00-0x1f) of literals,
    ;      but my assembler doesn't support short form labels yet.
EOF;
$code = $default_code;
if (isset($_REQUEST['code'])) {
  $code = $_REQUEST['code'];
}
echo htmlspecialchars($code);?></textarea>
</td>
      <!--
    ; Assembler test for DCPU
    ; by Markus Persson

    :start
      set i, 0
      set j, 0
      set b, 0xf100
    :nextchar
      set a, [data+i]
      ife a, 0
        set PC, end
      ifg a, 0xff
        set PC, setcolor
      bor a, b
      set [0x8000+j], a
      add i, 1
      add j, 1
      set PC, nextchar

    :setcolor
      set b, a
      and b, 0xff
      shl b, 8
      ifg a, 0x1ff
        add b, 0x80
      add i, 1
      set PC, nextchar


    :data
      dat 0x170, "Hello ", 0x2e1, "world", 0x170, ", how are you?"

    :end
      set PC, start
      -->
      <td width="30"><div class="hlight_wrap"><div class="line_highlight" id="hlight3"></div></div><div class="editor" id="offsets"></div></td>
      <td width="40%"><div class="hlight_wrap"><div class="line_highlight" id="hlight4"></div></div><div class="editor" id="dump"></div></td>
    </tr>
<tr valign=top><td></td><td colspan=3>
<!--<button id="loadsrc" onclick="ge('savesrc_f').click();">Load source...</button>
<button onclick="ge('savesrc_f').click();" id="savesrc">Save source...</button>
<button onclick="ge('savebin_f').click();" id="savebin">Save assembled code...</button>-->
<span class="notice">Click on the line numbers to toggle breakpoints.</span>
</td></tr>
    </table>
    </div>
    <div id="tab1_wrapper">
    <table width="100%" id="disassembler" cellpadding=0 cellspacing=0><tr valign=top>
      <td width="40%"><textarea class="editor" id="da_input" onkeyup="disassemble()" onchange="disassemble()" wrap=off placeholder="Place your hex codes here"></textarea></td>
      <td width="30"><div class="editor" id="da_lines"></div></td>
      <td width="60%"><div class="editor" id="da_code"></div></td>
    </tr>
<tr valign=top><td colspan=3>
<!--<button onclick="loadbin()" id="loadbin">Load binary...</button>
<button onclick="savebin2()" id="savebin2">Save binary...</button>
<button onclick="savedisasm()" id="savedisasm">Save disassembled code...</button>-->
</td></tr>
    </table>
    </div>
  </td>
  <td rowspan=2 width="20%" id="debugger" style="padding-left: 20px">
    <span>Cycles: </span><span id="cycles">0</span><br/>
    <button onclick="run(this)" id="button_run" class="big"/>&#8595; Run (F5)</button><button onclick="step()"  class="big"/>&#8618; Step (F6)</button><button onclick="reset()" class="big">&#8634; Reset</button><br/>
    <label for="show_pc"><input type="checkbox" id="show_pc" name="show_pc" checked="checked" onchange="toggleShowPC()"/> Show current line</label>
    <h4>Screen:</h4>
    <canvas id="screen" width="384" height="288"></canvas>
    <div class="notice">Keyboard input is available while the program is running.</div>
    <h4>Registers:</h4>
    <table border=0 class="editor">
    <tr>
      <td class="reg_name">PC:</td><td id="regPC" class="cur_pc">0</td>
      <td class="reg_name">SP:</td><td id="regSP" class="cur_sp">ffff</td>
    </tr> <tr>
      <td class="reg_name">A:</td><td id="regA">0</td>
      <td class="reg_name">B:</td><td id="regB">0</td>
      <td class="reg_name">C:</td><td id="regC">0</td>
    </tr> <tr>
      <td class="reg_name">X:</td><td id="regX">0</td>
      <td class="reg_name">Y:</td><td id="regY">0</td>
      <td class="reg_name">Z:</td><td id="regZ">0</td>
    </tr> <tr>
      <td class="reg_name">I:</td><td id="regI">0</td>
      <td class="reg_name">J:</td><td id="regJ">0</td>
    </tr> <tr>
      <td class="reg_name">O:</td><td id="regO">0</td>
    </tr>
    </table>

    <button onclick="disassembleDump()" id="disassembleDump">Disassemble</button>
    <h4>Memory dump:</h4>
    <div id="memory_wrapper">
      <div id="memory_window" onscroll="updateMemoryView()">
        <div id="memory_stub">
        <div id="memory_lines" class="editor"></div>
        <div id="memory_view" class="editor"></div></div>
      </div>
    </div>
  </td>
  </tr><tr valign=top>
  <td colspan=3>
  <div id="log" class="editor"></div></td>
  </tr></table>
  <script language="javascript">
    var cycles = 0;
    var memory = [];
    var registers = {A: 0, B: 0, C: 0, X: 0, Y: 0, Z: 0, I: 0, J: 0, PC: 0, SP: 0, O: 0};
    var memToLine = {};
    var lineToMem = {};
    var breaks = {};
    // Not final yet! Will most probably change after clarifications from Notch
    var keymap = {0x0d: 0x0a, 0x25: 0x01, 0x27: 0x02, 0x26: 0x03, 0x28: 0x04};
    var keypointer = 0;
    document.onkeydown = function(event) {
      var e = event || window.event;
      var key = e.keyCode;
      if (keymap[key]) key = keymap[key];
      switch (key) {
        case 116: { // F5
          run(ge("button_run"));
          return false;
        }
        case 117: { // F6
          step();
          return false;
        }
        default: { // pass it to program
          if (!runningTimer) {
            return true;
          }
          if (!memory[keypointer + 0x9000]) {
            memory[keypointer + 0x9000] = key;
            keypointer = (keypointer + 1) % 0x10;
            updateMemoryView();
          }
          return false;
        }
      }
      return true;
    }
    function toggleTab(index) {
      for (var i = 0; i < 2; i++) {
        ge("tab" + i + "_wrapper").style.display = (index == i) ? "block" : "none";
        ge("tab" + i).className = (index == i) ? "tab_active" : "tab_inactive";
      }
    }
    function updateRegisters() {
      for (var reg in registers) {
        ge("reg" + reg).innerHTML = pad(parseInt(registers[reg]).toString(16), 4);
      }
      ge("cycles").innerHTML = cycles;
    }
    function toggleShowPC() {
      updateHighlight();
    }
    updateRegisters();
    var blink = false;
    var palette = [
      [0x00, 0x00, 0x00, 0xff],
      [0x00, 0x00, 0xaa, 0xff],
      [0x00, 0xaa, 0x00, 0xff],
      [0x00, 0xaa, 0xaa, 0xff],
      [0xaa, 0x00, 0x00, 0xff],
      [0xaa, 0x00, 0xaa, 0xff],
      [0xaa, 0x55, 0x00, 0xff],
      [0xaa, 0xaa, 0xaa, 0xff],
      [0x55, 0x55, 0x55, 0xff],
      [0x55, 0x55, 0xff, 0xff],
      [0x55, 0xff, 0x55, 0xff],
      [0x55, 0xff, 0xff, 0xff],
      [0xff, 0x55, 0x55, 0xff],
      [0xff, 0x55, 0xff, 0xff],
      [0xff, 0xff, 0x55, 0xff],
      [0xff, 0xff, 0xff, 0xff]
    ];
    var ctx = ge('screen').getContext('2d');
    var image = ctx.createImageData(384, 288);
    // 0x000f, 0x0808
    var font = [0x0000, 0x0000, 0x080f, 0x0808, 0x08f8, 0x0808, 0x00ff, 0x0808, 0x0808, 0x0808, 0x08ff, 0x0808, 0x00ff, 0x1414, 0xff00, 0xff08, 0x1f10, 0x1714, 0xfc04, 0xf414, 0x1710, 0x1714, 0xf404, 0xf414, 0xff00, 0xf714, 0x1414, 0x1414, 0xf700, 0xf714, 0x1417, 0x1414, 0x0f08, 0x0f08, 0x14f4, 0x1414, 0xf808, 0xf808, 0x0f08, 0x0f08, 0x001f, 0x1414, 0x00fc, 0x1414, 0xf808, 0xf808, 0xff08, 0xff08, 0x14ff, 0x1414, 0x080f, 0x0000, 0x00f8, 0x0808, 0xffff, 0xffff, 0xf0f0, 0xf0f0, 0xffff, 0x0000, 0x0000, 0xffff, 0x0f0f, 0x0f0f, 0x0000, 0x0000, 0x005f, 0x0000, 0x0300, 0x0300, 0x3e14, 0x3e00, 0x266b, 0x3200, 0x611c, 0x4300, 0x3629, 0x7650, 0x0002, 0x0100, 0x1c22, 0x4100, 0x4122, 0x1c00, 0x2a1c, 0x2a00, 0x083e, 0x0800, 0x4020, 0x0000, 0x0808, 0x0800, 0x0040, 0x0000, 0x601c, 0x0300, 0x3e41, 0x3e00, 0x427f, 0x4000, 0x6259, 0x4600, 0x2249, 0x3600, 0x0f08, 0x7f00, 0x2745, 0x3900, 0x3e49, 0x3200, 0x6119, 0x0700, 0x3649, 0x3600, 0x2649, 0x3e00, 0x0024, 0x0000, 0x4024, 0x0000, 0x0814, 0x2241, 0x1414, 0x1400, 0x4122, 0x1408, 0x0259, 0x0600, 0x3e59, 0x5e00, 0x7e09, 0x7e00, 0x7f49, 0x3600, 0x3e41, 0x2200, 0x7f41, 0x3e00, 0x7f49, 0x4100, 0x7f09, 0x0100, 0x3e49, 0x3a00, 0x7f08, 0x7f00, 0x417f, 0x4100, 0x2040, 0x3f00, 0x7f0c, 0x7300, 0x7f40, 0x4000, 0x7f06, 0x7f00, 0x7f01, 0x7e00, 0x3e41, 0x3e00, 0x7f09, 0x0600, 0x3e41, 0xbe00, 0x7f09, 0x7600, 0x2649, 0x3200, 0x017f, 0x0100, 0x7f40, 0x7f00, 0x1f60, 0x1f00, 0x7f30, 0x7f00, 0x7708, 0x7700, 0x0778, 0x0700, 0x7149, 0x4700, 0x007f, 0x4100, 0x031c, 0x6000, 0x0041, 0x7f00, 0x0201, 0x0200, 0x8080, 0x8000, 0x0001, 0x0200, 0x2454, 0x7800, 0x7f44, 0x3800, 0x3844, 0x2800, 0x3844, 0x7f00, 0x3854, 0x5800, 0x087e, 0x0900, 0x4854, 0x3c00, 0x7f04, 0x7800, 0x447d, 0x4000, 0x2040, 0x3d00, 0x7f10, 0x6c00, 0x417f, 0x4000, 0x7c18, 0x7c00, 0x7c04, 0x7800, 0x3844, 0x3800, 0x7c14, 0x0800, 0x0814, 0x7c00, 0x7c04, 0x0800, 0x4854, 0x2400, 0x043e, 0x4400, 0x3c40, 0x7c00, 0x1c60, 0x1c00, 0x7c30, 0x7c00, 0x6c10, 0x6c00, 0x4c50, 0x3c00, 0x6454, 0x4c00, 0x0836, 0x4100, 0x0077, 0x0000, 0x4136, 0x0800, 0x0201, 0x0201, 0x704c, 0x7000]; // default font by Notch
    function redrawScreen() {
      var offs = 0x8000;
      var sz = 3; // each screen pixel equals to 3 "real" pixels
      for (var i = 0; i < 12; i++) {
        for (var j = 0; j < 32; j++) {
          var value = memory[offs];
          var idx = (value & 0x7f) << 1;
          var blinking = (value & 0x80);
          var bg_color = palette[0x0];
          var fg_color = palette[0xf];
          if ((value >> 8) > 0) {
            bg_color = palette[(value >> 8) & 0xf];
            fg_color = palette[(value >> 12) & 0xf];
          }
          for (var ax = 0; ax < 4; ax++) {
            var byte = 0;
            if (!blinking || !blink) {
              switch (ax) {
                case 0: byte = memory[0x8180 + idx] >> 8; break;
                case 1: byte = memory[0x8180 + idx] & 0xff; break;
                case 2: byte = memory[0x8181 + idx] >> 8; break;
                case 3: byte = memory[0x8181 + idx] & 0xff; break;
              }
            }
            for (var ay = 0; ay < 8; ay++) {
              var color = (byte & 1) ? fg_color : bg_color;
              for (var x = 0; x < sz; x++) {
                for (var y = 0; y < sz; y++) {
                  for (var k = 0; k < 4; k++) {
                    // oh, we are so deep now...
                    image.data[((i * 8 + ay) * sz + y) * (32 * 4 * sz * 4) + ((j * 4 + ax) * sz + x) * 4 + k] = color[k];
                  }
                }
              }
              byte >>= 1;
            }
          }
          offs++;
        }
      }
      ctx.putImageData(image, 0, 0); // redraw
      var back_color = palette[memory[0x8280] & 0xf];
      ge('screen').style.backgroundColor = '#' + pad(back_color[0].toString(16), 2) + pad(back_color[1].toString(16), 2) + pad(back_color[2].toString(16), 2);
    }
    function updateMemoryView() {
      var lns = "";
      var s = "";
      var offs = ge("memory_window").scrollTop * 8;
      ge("memory_lines").style.top = (offs / 8) + "px";
      ge("memory_view").style.top = (offs / 8) + "px";
      for (var i = 0; i < 16; i++) {
        lns += pad((offs + i * 8).toString(16), 4) + ":<br/>";
        for (var j = 0; j < 8; j++) {
          var v = memory[offs + i * 8 + j];
          if (!v) v = 0;
          v = pad(v.toString(16), 4);
          if (((offs + i * 8 + j + 1) & 0xffff) == registers.SP) {
            s += " <u class='cur_sp'>" + v + "</u>";
          } else
          if (offs + i * 8 + j == registers.PC) {
            s += " <u class='cur_pc'>" + v + "</u>";
          } else {
            s += " " + v;
          }
        }
        s += "<br/>";
      }
      ge("memory_lines").innerHTML = lns;
      ge("memory_view").innerHTML = s;

      redrawScreen();
    }
    updateMemoryView();
    function positionHighlight(line) {
      if (!ge("show_pc").checked) {
        line = -1;
      }
      for (var i = 1; i <= 4; i++) {
        var hlight = ge("hlight" + i);
        if (line >= 0) {
          hlight.style.top = line * 19 + 2;
          hlight.style.display = "block";
        } else {
          hlight.style.display = "none";
        }
      }
    }
    function updateHighlight() {
      positionHighlight(memToLine[registers.PC] - 1);
    }
    positionHighlight(-1);
    function reset() {
      for (var i = 0; i < 0xffff; i++) {
        if (memory[i]) memory[i] = 0;
      }
      for (var i = 0; i < 256; i++) {
        memory[0x8180 + i] = font[i]; // put default font
      }
      for (var reg in registers) {
        registers[reg] = 0;
      }
      registers.SP = 0;
      cycles = 0;
      keypointer = 0;
      assemble();
    }
    var logger = function(offset, msg, fatal) {
      //log.push(pad(line + 1, 5) + ": " + (fatal ? "(Fatal) " : "") + msg);
      if (fatal) clearInterval(runningTimer);
    };
    function step() {
      cycles += DCPU.step(memory, registers);
      updateHighlight();
      updateRegisters();
      updateMemoryView();
    }
    var runningTimer = false;
    function run(button) {
      if (runningTimer) {
        clearInterval(runningTimer);
        runningTimer = false;
        button.innerHTML = "&#8595; Run (F5)";
        updateHighlight();
        updateRegisters();
        updateMemoryView();
      } else {
        runningTimer = setInterval(function() {
          var was_cycles = cycles;
          for (var i = 0; i < 10000; i++) {
            cycles += DCPU.step(memory, registers);
            if (!runningTimer) return;
            if (breaks[memToLine[registers.PC] - 1]) {
              run(button);
              return;
            }
            if (cycles > was_cycles + 5213) break;
          }
          updateHighlight();
          updateRegisters();
          updateMemoryView();
        }, 50);
        button.innerHTML = "&#215; Stop (F5)";
      }
    }
    function bp(line) {
      breaks[line] = !breaks[line] && (lineToMem[line] !== undefined);
      ge("ln" + line).className = breaks[line] ? "breakpoint" : "";
    }
    function pad(v, w) {
      var s = "" + v;
      var len = s.length;
      for (var i = 0; i < w - len; i++)
        s = "0" + s;
      return s;
    }
    function assemble() {
      lastCode = ge("code").value;
      var lines = lastCode.split("\n");
      var labels = {};
      var linenums = [];
      var offsets = [];
      var dump = [];
      var log = [];
      var aborted = false;
      var logger = function(line, offset, msg, fatal) {
        log.push("<span class='line'>" + pad(line + 1, 5) + ":</span> " + (fatal ? "(<span class='fatal'>Fatal</span>) " : "") + msg);
        if (fatal) aborted = true;
      };
      // get values of labels
      var sp = 0;
      var last = false;
      memToLine = {};
      lineToMem = {};
      for (var i = 0; i < lines.length && !aborted; i++) {
        linenums.push("<u id=ln" + i + " onclick='bp(" + i + ")'>" + (i + 1) + "</u>");
      }
      for (var i = 0; i < 0xffff; i++) {
        if (memory[i]) memory[i] = 0;
      }
      for (var i = 0; i < 256; i++) {
        memory[0x8180 + i] = font[i]; // put default font
      }
      for (var i = 0; i < lines.length && !aborted; i++) {
        var info = DCPU.compileLine(i, sp, lines[i], false, logger);
        if (aborted) break;
        if (info.label) {
          if (DCPU.reserved.indexOf(info.label.toUpperCase()) >= 0) {
            logger(i, sp, "\"" + info.label + "\" is reserved keyword, you can't use it as label name", true);
            break;
          } else
          if (labels[info.label]) {
            logger(i, sp, "Duplicate label \"" + info.label + "\"");
          }
          labels[info.label] = sp;
        }
        if (sp + info.max_size > 0xFFFF) {
          logger(i, sp, "Code is too big (exceeds 128 Kb), not enough memory", true);
          break;
        } else
        if (sp + info.max_size > 0x8000) {
          logger(i, sp, "Code is too big (exceeds 64 Kb), overlaps videomemory - there will be glitches on screen)");
        }
        if (info.max_size > 0) {
          lineToMem[i] = sp;
          offsets.push(pad(sp.toString(16), 4) + ":");
        } else {
          offsets.push("");
        }
        if (info.org !== undefined) {
          sp = info.org;
        } else {
          sp += info.max_size;
        }
      }
      sp = 0;
      for (var i = 0; i < lines.length && !aborted; i++) {
        var info = DCPU.compileLine(i, sp, lines[i], labels, logger);
        if (aborted) break;
        var s = "";
        for (var j = 0; j < info.dump.length; j++) {
          s += pad(info.dump[j].toString(16), 4) + " ";
          memory[sp + j] = info.dump[j];
          memToLine[sp + j] = i + 1;
        }
        dump.push(s);
        if (info.org !== undefined) {
          sp = info.org;
        } else {
          sp += info.max_size;
        }
        if (info.op) last = info;
      }
      if (aborted) {
        offsets = [];
        dump = [];
      }

      // update UI
      ge("linenums").innerHTML = linenums.join("");
      ge("offsets").innerHTML = offsets.join("<br/>");
      ge("dump").innerHTML = dump.join("<br/>");
      ge("log").innerHTML = log.join("<br/>");
      ge("code").style.height = Math.max(560, ((lines.length + 1) * 19 + 9)) + "px";

      for (var line in breaks) {
        if (breaks[line] && (lineToMem[line] === undefined)) {
          bp(line);
        } else
          ge("ln" + line).className = breaks[line] ? "breakpoint" : "";
      }
      updateMemoryView();
      updateHighlight();
      updateRegisters();
    }
    function disassemble() {
      lastInput = ge("da_input").value;
      var input = lastInput + " ";
      var linenum = lastInput.split("\n").length;
      var data = [];
      var s = "";
      for (var i = 0; i < input.length; i++) {
        if ("0123456789abcdefABCDEF".indexOf(input.charAt(i)) > -1) {
          s += input.charAt(i);
          if (s.length == 4) {
            data.push(parseInt(s, 16));
            s = "";
          }
        }
      }

      var log = [];
      var aborted = false;
      var logger = function(offset, msg, fatal) {
        log.push("<span class='line'>" + pad(offset, 4) + ":</span> " + (fatal ? "(<span class='fatal'>Fatal</span>) " : "") + msg);
        if (fatal) aborted = true;
      };

      var used = {};
      var code = {};
      var stack = [];
      var conditional = false;
      if (data.length > 0) {
        stack.push(0);
      }
      var labels = {last: 0};
      while (stack.length > 0) {
        var pc = stack.pop();
        if (used[pc]) {
          continue;
        }
        do {
          var info = DCPU.disassemble(data, pc, labels, logger);
          if (info.branch !== undefined) {
            stack.push(info.branch);
          }
          for (var i = pc; i < pc + info.size; i++) {
            used[i] = true;
          }
          if (info.code !== undefined) {
            code[pc] = (conditional ? "&nbsp;&nbsp;" : "") + info.code;
          }
          pc += info.size;
          if (conditional) {
            info.terminal = false;
          }
          conditional = info.conditional;
        } while (pc < data.length && !info.terminal);
      }

      var lines = [];
      var output = [];
      for (var i = 0; i < data.length; i++) {
        if (labels[i]) {
          lines.push("");
          output.push("");
          lines.push("");
          output.push(":" + wrapAs(labels[i], "lbl"));
        }
        if (code[i] !== undefined) {
          lines.push(pad(i.toString(16), 4) + ":");
          output.push("&nbsp;&nbsp;" + code[i]);
        } else
        if (!used[i]) {
          var words = [];
          var all_zeros = true;
          var old_i = i;
          while (i < data.length && !used[i]) {
            words.push(wrapAs("0x" + pad(data[i].toString(16), 4), "lit"));
            if (data[i]) all_zeros = false;
            i++;
          }
          if (all_zeros) {
            if (i < data.length) {
              lines.push("");
              lines.push("");
              output.push("");
              output.push(wrapAs("ORG", "op") + " " + wrapAs("0x" + pad(i.toString(16), 4), "lit"));
            }
          } else {
            lines.push(pad(old_i.toString(16), 4) + ":");
            output.push("&nbsp;&nbsp;" + wrapAs("DAT", "op") + " " + words.join(", "));
          }
          i--;
        }
      }

      // update UI
      ge("da_lines").innerHTML = lines.join("<br/>");
      ge("da_code").innerHTML = output.join("<br/>");
      ge("log").innerHTML = log.join("<br/>");
      ge("da_input").style.height = Math.max(560, ((linenum + 1) * 19 + 9)) + "px";
    }
    function disassembleDump() {
      var dump = "";
      var end = 0x7ffe;
      while (!memory[end] && end > 0) end--;
      for (var i = 0; i <= end + 1; i++) {
        dump += pad((memory[i] || 0).toString(16), 4);
        dump += (i % 8 == 7) ? "\n" : " ";
      }
      ge("da_input").value = dump;
      disassemble();
      toggleTab(1);
    }
    disassemble();
    reset();
    var lastCode = ge("code").value;
    var lastInput = ge("da_input").value;
    setInterval(function() {
      blink = !blink;
      redrawScreen();

      var code = ge("code").value;
      if (code != lastCode) {
        lastCode = code;
        assemble();
      }
      var input = ge("code").value;
      if (input != lastInput) {
        lastInput = input;
        //disassemble();
      }
    }, 600);
  </script>
</body>
</html>