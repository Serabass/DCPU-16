<html>
<head>
  <title>DCPU-16 emulator</title>
  <script type="text/javascript" src="assembler.js"></script>
  <script type="text/javascript" src="dcpu.js"></script>
  <script type="text/javascript" src="screen.js"></script>
  <script type="text/javascript" src="test.js"></script>
  <style>
    body, button {
      font-family: Verdana, Tahoma, sans-serif;
      font-size: 14px;
    }
    button.big {
      font-size: 20px;
      width: 160px;
      height: 40px;
      text-align: left;
      margin: 4px;
    }
    .filewrap {
      margin: 6px 6px 0px 0px;
      position: relative;
      display: inline-block;
    }
    .filewrap .file {
      position: absolute;
      opacity: 0;
      -moz-opacity: 0;
      filter:alpha(opacity=0);
      margin: 0;
      width: 100%;
      height: 100%;
      z-index: -100;
    }

    h3 {
      font-size: 22px;
      margin-bottom: 0px;
    }
    table td {
      position: relative;
    }
    .editor, .editor td {
      font-family: monospace;
      font-size: 14px;
      line-height: 19px;
      margin: 0;
    }
    #linenums {
      padding: 2px 0px 2px 0px;
      text-align: right;
      color: gray;
    }
    #linenums u {
      margin: 1px 1px 2px 1px;
      padding: 1px 11px;
      line-height: 15px;
      text-decoration: none;
      display: block;
      cursor: pointer;
    }
    #linenums u.breakpoint {
      padding: 0px 10px;
      background-color: #adf;
      border: 1px solid #3ab;
      border-radius: 3px;
    }
    #offsets {
      padding: 4px 10px 2px 24px;
      color: gray;
    }
    #da_lines {
      padding: 4px 10px 2px 24px;
      color: gray;
    }
    #code {
      width: 100%;
      min-width: 500px;
      background-color: transparent;
    }
    #da_input {
      width: 100%;
      min-width: 200px;
    }
    #dump {
      overflow-x: auto;
      overflow-y: visible;
      white-space: nowrap;
      padding: 4px;
      width: 300px;
    }
    #da_code {
      padding: 4px;
    }
    #log {
      padding-top: 6px;
    }
    #log .line {
      color: gray;
    }
    #log .fatal {
      font-weight: bold;
      color: #900;
    }
    #memory_wrapper {
      position: relative;
    }
    #memory_window {
      overflow-y: scroll;
      width: 400px;
      height: 304px;
    }
    #memory_stub {
      height: 8480px;
    }
    #memory_view {
      position: relative;
      float: left;
      top: 0px;
      left:0px;
    }
    #memory_lines {
      position: relative;
      float: left;
      top: 0px;
      left: 0px;
      padding-right: 6px;
      color: gray;
    }
    .reg_name {
      padding-left: 20px;
      font-weight: bold;
      color: gray;
    }
    .cur_sp {
      background-color: #aaaaff;
      text-decoration: none;
    }
    .cur_pc {
      background-color: #aaffaa;
      text-decoration: none;
    }
    .line_highlight {
      background-color: #aaffaa;
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 19px;
      z-index: -1000;
    }
    .hlight_wrap {
      position: relative;
    }
    #screen {
      background-color: black;
      color: white;
      width: 384px;
      height: 288px;
      padding: 0px;
      border: solid 5px #444;
    }
    .notice {
      margin: 6px 0px 10px 0px;
      color: gray;
      font-size: 14px;
    }
    .notice a {
      color: black;
    }
    #tab1_wrapper {
      display: none;
    }
    #da_code .op {
      font-weight: bold;
      color: #700;
    }
    #da_code .reg {
      font-weight: bold;
      color: #070;
    }
    #da_code .lit {
      color: #007;
    }
    #da_code .kw {
      color: #077;
    }
    #da_code .lbl {
      color: #707;
    }
    .tabs {
      margin-bottom: 2px;
    }
    .tab_active {
      background-color: #8AE;
      color: white;
      padding: 2px 7px;
      text-decoration: none;
      border-radius: 4px 4px 0px 0px;
      margin: 0px 5px;
    }
    .tab_inactive {
      background-color: #FFF;
      color: #57C;
      padding: 2px 7px;
      text-decoration: none;
      border-radius: 4px 4px 0px 0px;
      margin: 0px 5px;
    }
    #disassembleDump {
      float: right;
      margin-top: 19px;
    }
  </style>
</head>
<body>
  <h3>DCPU-16 Assembler, Emulator &amp; Disassembler</h3>
  <div class="notice">by deNULL. Report any problems at <a href="mailto:me@denull.ru">me@denull.ru</a>.</div>

  <table width="100%" border=0 cellpadding=0 cellspacing=0 style="padding-top: 6px"><tr valign=top>
  <td width="80%">
    <div class="tabs"><a href="javascript:" onclick="toggleTab(0)" class="tab_active" id="tab0">Assembler</a><a href="javascript:" onclick="toggleTab(1)" class="tab_inactive" id="tab1">Disassembler</a></div>
    <div id="tab0_wrapper">
    <table width="100%" id="assembler" cellpadding=0 cellspacing=0><tr valign=top>
      <td width="20"><div class="hlight_wrap"><div class="line_highlight" id="hlight1"></div></div><div class="editor" id="linenums"></div></td>
      <td width="60%"><div class="hlight_wrap"><div class="line_highlight" id="hlight2"></div></div><textarea class="editor" id="code" onkeyup="assemble()" onchange="assemble()" wrap=off spellcheck=false placeholder="Place your code here">
; your code here
</textarea>
</td>
      <!--
    ; Assembler test for DCPU
    ; by Markus Persson

    :start
      set i, 0
      set j, 0
      set b, 0xf100
    :nextchar
      set a, [data+i]
      ife a, 0
        set PC, end
      ifg a, 0xff
        set PC, setcolor
      bor a, b
      set [0x8000+j], a
      add i, 1
      add j, 1
      set PC, nextchar

    :setcolor
      set b, a
      and b, 0xff
      shl b, 8
      ifg a, 0x1ff
        add b, 0x80
      add i, 1
      set PC, nextchar


    :data
      dat 0x170, "Hello ", 0x2e1, "world", 0x170, ", how are you?"

    :end
      set PC, start
      -->
      <td width="30"><div class="hlight_wrap"><div class="line_highlight" id="hlight3"></div></div><div class="editor" id="offsets"></div></td>
      <td width="40%"><div class="hlight_wrap"><div class="line_highlight" id="hlight4"></div></div><div class="editor" id="dump"></div></td>
    </tr>
<tr valign=top><td></td><td colspan=3>
<!--<button id="loadsrc" onclick="ge('savesrc_f').click();">Load source...</button>
<button onclick="ge('savesrc_f').click();" id="savesrc">Save source...</button>
<button onclick="ge('savebin_f').click();" id="savebin">Save assembled code...</button>-->
<span class="notice">Click on the line numbers to toggle breakpoints.</span>
</td></tr>
    </table>
    </div>
    <div id="tab1_wrapper">
    <table width="100%" id="disassembler" cellpadding=0 cellspacing=0><tr valign=top>
      <td width="40%"><textarea class="editor" id="da_input" onkeyup="disassemble()" onchange="disassemble()" wrap=off placeholder="Place your hex codes here"></textarea></td>
      <td width="30"><div class="editor" id="da_lines"></div></td>
      <td width="60%"><div class="editor" id="da_code"></div></td>
    </tr>
<tr valign=top><td colspan=3>
<!--<button onclick="loadbin()" id="loadbin">Load binary...</button>
<button onclick="savebin2()" id="savebin2">Save binary...</button>
<button onclick="savedisasm()" id="savedisasm">Save disassembled code...</button>-->
</td></tr>
    </table>
    </div>
  </td>
  <td rowspan=2 width="20%" id="debugger" style="padding-left: 20px">
    <span>Cycles: </span><span id="cycles">0</span><br/>
    <button onclick="run(this)" id="button_run" class="big"/>&#8595; Run (F5)</button><button onclick="step()"  class="big"/>&#8618; Step (F6)</button><button onclick="reset()" class="big">&#8634; Reset</button><br/>
    <label for="show_pc"><input type="checkbox" id="show_pc" name="show_pc" checked="checked" onchange="toggleShowPC()"/> Show current line</label>
    <h4>Screen:</h4>
    <canvas width="128" height="96" id="screen"></canvas><br>
    <canvas width="128" height="32" style="display:none" id="fontCanvas"></canvas>
    <div class="notice">Keyboard input is available while the program is running.</div>
    <h4>Registers:</h4>
    <table border=0 class="editor">
    <tr>
      <td class="reg_name">PC:</td><td id="regPC" class="cur_pc">0</td>
      <td class="reg_name">SP:</td><td id="regSP" class="cur_sp">ffff</td>
    </tr> <tr>
      <td class="reg_name">A:</td><td id="regA">0</td>
      <td class="reg_name">B:</td><td id="regB">0</td>
      <td class="reg_name">C:</td><td id="regC">0</td>
    </tr> <tr>
      <td class="reg_name">X:</td><td id="regX">0</td>
      <td class="reg_name">Y:</td><td id="regY">0</td>
      <td class="reg_name">Z:</td><td id="regZ">0</td>
    </tr> <tr>
      <td class="reg_name">I:</td><td id="regI">0</td>
      <td class="reg_name">J:</td><td id="regJ">0</td>
    </tr> <tr>
      <td class="reg_name">O:</td><td id="regO">0</td>
    </tr>
    </table>

    <button onclick="disassembleDump()" id="disassembleDump">Disassemble</button>
    <h4>Memory dump:</h4>
    <div id="memory_wrapper">
      <div id="memory_window" onscroll="updateMemoryView()">
        <div id="memory_stub">
        <div id="memory_lines" class="editor"></div>
        <div id="memory_view" class="editor"></div></div>
      </div>
    </div>
  </td>
  </tr><tr valign=top>
  <td colspan=3>
  <div id="log" class="editor"></div></td>
  </tr></table>
  <script language="javascript">
    var cycles = 0;
    var memory = [];
    var registers = {A: 0, B: 0, C: 0, X: 0, Y: 0, Z: 0, I: 0, J: 0, PC: 0, SP: 0, O: 0};
    var memToLine = {};
    var lineToMem = {};
    var breaks = {};
    // Not final yet! Will most probably change after clarifications from Notch
    var keymap = {0x0d: 0x0a, 0x25: 0x01, 0x27: 0x02, 0x26: 0x03, 0x28: 0x04};
    var keypointer = 0;
    document.onkeydown = function(event) {
      var e = event || window.event;
      var key = e.keyCode;
      if (keymap[key]) key = keymap[key];
      switch (key) {
        case 116: { // F5
          run(ge("button_run"));
          return false;
        }
        case 117: { // F6
          step();
          return false;
        }
        default: { // pass it to program
          if (!runningTimer) {
            return true;
          }
          if (!memory[keypointer + 0x9000]) {
            memory[keypointer + 0x9000] = key;
            keypointer = (keypointer + 1) % 0x10;
            updateMemoryView();
          }
          return false;
        }
      }
      return true;
    }
    function toggleTab(index) {
      for (var i = 0; i < 2; i++) {
        ge("tab" + i + "_wrapper").style.display = (index == i) ? "block" : "none";
        ge("tab" + i).className = (index == i) ? "tab_active" : "tab_inactive";
      }
    }
    function updateRegisters() {
      for (var reg in registers) {
        ge("reg" + reg).innerHTML = pad(parseInt(registers[reg]).toString(16), 4);
      }
      ge("cycles").innerHTML = cycles;
    }
    function toggleShowPC() {
      updateHighlight();
    }
    updateRegisters();

    function updateMemoryView() {
      var lns = "";
      var s = "";
      var offs = ge("memory_window").scrollTop * 8;
      ge("memory_lines").style.top = (offs / 8) + "px";
      ge("memory_view").style.top = (offs / 8) + "px";
      for (var i = 0; i < 16; i++) {
        lns += pad((offs + i * 8).toString(16), 4) + ":<br/>";
        for (var j = 0; j < 8; j++) {
          var v = memory[offs + i * 8 + j];
          if (!v) v = 0;
          v = pad(v.toString(16), 4);
          if (((offs + i * 8 + j + 1) & 0xffff) == registers.SP) {
            s += " <u class='cur_sp'>" + v + "</u>";
          } else
          if (offs + i * 8 + j == registers.PC) {
            s += " <u class='cur_pc'>" + v + "</u>";
          } else {
            s += " " + v;
          }
        }
        s += "<br/>";
      }
      ge("memory_lines").innerHTML = lns;
      ge("memory_view").innerHTML = s;

    }
    updateMemoryView();
    function positionHighlight(line) {
      if (!ge("show_pc").checked) {
        line = -1;
      }
      for (var i = 1; i <= 4; i++) {
        var hlight = ge("hlight" + i);
        if (line >= 0) {
          hlight.style.top = line * 19 + 2;
          hlight.style.display = "block";
        } else {
          hlight.style.display = "none";
        }
      }
    }
    function updateHighlight() {
      positionHighlight(memToLine[registers.PC] - 1);
    }
    positionHighlight(-1);
    function reset() {
      for (var i = 0; i < 0xffff; i++) {
        if (memory[i]) memory[i] = 0;
      }
      for (var reg in registers) {
        registers[reg] = 0;
      }
      registers.SP = 0;
      cycles = 0;
      keypointer = 0;
      assemble();
    }
    var logger = function(offset, msg, fatal) {
      //log.push(pad(line + 1, 5) + ": " + (fatal ? "(Fatal) " : "") + msg);
      if (fatal) clearInterval(runningTimer);
    };

    function updateViews(show_all) {
      if (show_all) {
        updateHighlight();
        updateMemoryView();
      }
      updateRegisters();
      Screen.update(memory);
      document.getElementById("cycles").innerHTML = cycles;
    }

    function step() {
      var rv = DCPU.step(memory, registers);
      if (rv > 0) {
        cycles += rv;
      }
      updateViews(true);
    }

    var runningTimer = false;
    function run(button) {
      if (runningTimer) {
        clearInterval(runningTimer);
        runningTimer = false;
        button.innerHTML = "&#8595; Run (F5)";
        updateViews(true);
      } else {
        runningTimer = setInterval(function() {
          var was_cycles = cycles;
          for (var i = 0; i < 10000; i++) {
            var rv = DCPU.step(memory, registers);
            if (rv < 0) { // break
              if (runningTimer) run(button);
              return;
            }
            cycles += rv;
            if (!runningTimer) return;
            if (breaks[memToLine[registers.PC] - 1]) {
              run(button);
              return;
            }
            if (cycles > was_cycles + 5213) break;
          }
          updateViews(false);
        }, 50);
        button.innerHTML = "&#215; Stop (F5)";
      }
    }
    function bp(line) {
      breaks[line] = !breaks[line] && (lineToMem[line] !== undefined);
      ge("ln" + line).className = breaks[line] ? "breakpoint" : "";
    }
    function pad(v, w) {
      var s = "" + v;
      var len = s.length;
      for (var i = 0; i < w - len; i++)
        s = "0" + s;
      return s;
    }

    function assemble() {
      var lines = ge("code").value.split("\n");
      var log = [];

      var linenums = [];
      for (var i = 0; i < lines.length; i++) {
        linenums.push("<u id=ln" + i + " onclick='bp(" + i + ")'>" + (i + 1) + "</u>");
      }
      ge("linenums").innerHTML = linenums.join("");

      var logger = function(line, address, pos, message, fatal) {
        log.push("<span class='line'>" + pad(line + 1, 5) + ":</span> " +
          (fatal ? "(<span class='fatal'>Fatal</span>) " : "") +
          message);
        ge("ln" + line).style.backgroundColor = '#f88';
      };
      for (var i = 0; i < 0xffff; i++) {
        if (memory[i]) memory[i] = 0;
      }
      var rv = Assembler.compile(lines, memory, logger);

      // map line # to address, and build up offsets/dump
      memToLine = {};
      lineToMem = {};
      var offsets = [];
      var dump = [];
      if (rv) {
        for (var i = 0; i < lines.length; i++) {
          if (rv.infos[i] === undefined || rv.infos[i].size == 0) {
            offsets.push("");
            dump.push("");
          } else {
            var info = rv.infos[i];
            offsets.push(pad(info.pc.toString(16), 4) + ":");
            lineToMem[i] = info.pc;
            var s = "";
            for (var j = 0; j < info.dump.length; j++) {
              s += pad(info.dump[j].toString(16), 4) + " ";
              memToLine[info.pc + j] = i + 1;
            }
            dump.push(s);
          }
        }
      }

      // update UI
      ge("offsets").innerHTML = offsets.join("<br/>");
      ge("dump").innerHTML = dump.join("<br/>");
      ge("log").innerHTML = log.join("<br/>");
      ge("code").style.height = Math.max(560, ((lines.length + 1) * 19 + 9)) + "px";

      for (var line in breaks) {
        if (breaks[line] && (lineToMem[line] === undefined)) {
          bp(line);
        } else
          ge("ln" + line).className = breaks[line] ? "breakpoint" : "";
      }
      updateViews(true);
    }

    function disassemble() {
      lastInput = ge("da_input").value;
      var input = lastInput + " ";
      var linenum = lastInput.split("\n").length;
      var data = [];
      var s = "";
      for (var i = 0; i < input.length; i++) {
        if ("0123456789abcdefABCDEF".indexOf(input.charAt(i)) > -1) {
          s += input.charAt(i);
          if (s.length == 4) {
            data.push(parseInt(s, 16));
            s = "";
          }
        }
      }

      var log = [];
      var aborted = false;
      var logger = function(offset, msg, fatal) {
        log.push("<span class='line'>" + pad(offset, 4) + ":</span> " + (fatal ? "(<span class='fatal'>Fatal</span>) " : "") + msg);
        if (fatal) aborted = true;
      };

      var used = {};
      var code = {};
      var stack = [];
      var conditional = false;
      if (data.length > 0) {
        stack.push(0);
      }
      var labels = {last: 0};
      while (stack.length > 0) {
        var pc = stack.pop();
        if (used[pc]) {
          continue;
        }
        do {
          var info = DCPU.disassemble(data, pc, labels, logger);
          if (info.branch !== undefined) {
            stack.push(info.branch);
          }
          for (var i = pc; i < pc + info.size; i++) {
            used[i] = true;
          }
          if (info.code !== undefined) {
            code[pc] = (conditional ? "&nbsp;&nbsp;" : "") + info.code;
          }
          pc += info.size;
          if (conditional) {
            info.terminal = false;
          }
          conditional = info.conditional;
        } while (pc < data.length && !info.terminal);
      }

      var lines = [];
      var output = [];
      for (var i = 0; i < data.length; i++) {
        if (labels[i]) {
          lines.push("");
          output.push("");
          lines.push("");
          output.push(":" + wrapAs(labels[i], "lbl"));
        }
        if (code[i] !== undefined) {
          lines.push(pad(i.toString(16), 4) + ":");
          output.push("&nbsp;&nbsp;" + code[i]);
        } else if (!used[i]) {
          var words = [];
          var all_zeros = true;
          var old_i = i;
          while (i < data.length && !used[i]) {
            words.push(wrapAs("0x" + pad(data[i].toString(16), 4), "lit"));
            if (data[i]) all_zeros = false;
            i++;
          }
          if (all_zeros) {
            if (i < data.length) {
              lines.push("");
              lines.push("");
              output.push("");
              output.push(wrapAs("ORG", "op") + " " + wrapAs("0x" + pad(i.toString(16), 4), "lit"));
            }
          } else {
            lines.push(pad(old_i.toString(16), 4) + ":");
            output.push("&nbsp;&nbsp;" + wrapAs("DAT", "op") + " " + words.join(", "));
          }
          i--;
        }
      }

      // update UI
      ge("da_lines").innerHTML = lines.join("<br/>");
      ge("da_code").innerHTML = output.join("<br/>");
      ge("log").innerHTML = log.join("<br/>");
      ge("da_input").style.height = Math.max(560, ((linenum + 1) * 19 + 9)) + "px";
    }
    function disassembleDump() {
      var dump = "";
      var end = 0x7ffe;
      while (!memory[end] && end > 0) end--;
      for (var i = 0; i <= end + 1; i++) {
        dump += pad((memory[i] || 0).toString(16), 4);
        dump += (i % 8 == 7) ? "\n" : " ";
      }
      ge("da_input").value = dump;
      disassemble();
      toggleTab(1);
    }

    Screen.init();
    disassemble();
    assemble();
    var blink = false;
    var lastCode = ge("code").value;
    var lastInput = ge("da_input").value;
    setInterval(function() {
      blink = !blink;
      var els = ge("screen").getElementsByTagName("b");
      for (var i in els) {
        els[i].className = blink ? "h" : "";
      }

      var code = ge("code").value;
      if (code != lastCode) {
        lastCode = code;
        assemble();
      }
      var input = ge("code").value;
      if (input != lastInput) {
        lastInput = input;
        //disassemble();
      }
    }, 600);
  </script>
</body>
</html>